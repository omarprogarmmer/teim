<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ØªØªØ¨Ø¹ ÙˆÙ‚Øª Ø§Ù„Ø¯Ø±Ø§Ø³Ø© - Ø£ÙˆÙÙ„Ø§ÙŠÙ†</title>
  <style>
    :root {
      --main-color: #4CAF50;
      --accent-color: #388E3C;
      --bg-color: #f1fdf3;
      --text-color: #222;
    }

    body {
      margin: 0;
      padding: 1rem;
      font-family: 'Tajawal', sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    h1 {
      font-size: 1.8rem;
      margin-bottom: 1rem;
      color: var(--main-color);
      text-align: center;
    }

    .timer {
      font-size: 2.5rem;
      font-weight: bold;
      margin: 1rem 0;
      color: #333;
    }

    .buttons {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.8rem;
      margin-bottom: 1.5rem;
      width: 100%;
      max-width: 400px;
    }

    button {
      flex: 1 1 45%;
      padding: 1rem;
      font-size: 1rem;
      border: none;
      border-radius: 10px;
      background-color: var(--main-color);
      color: white;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      cursor: pointer;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: var(--accent-color);
    }

    .info {
      font-size: 1.1rem;
      margin-bottom: 1.5rem;
      text-align: center;
    }

    .section {
      background-color: white;
      padding: 1rem;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      width: 100%;
      max-width: 400px;
      margin-bottom: 2rem;
      position: relative;
    }

    .section h2 {
      font-size: 1.2rem;
      color: var(--accent-color);
      margin-bottom: 0.5rem;
    }

    input[type="number"] {
      padding: 0.5rem;
      font-size: 1rem;
      width: 100px;
      border-radius: 8px;
      border: 1px solid #ccc;
      text-align: center;
    }

    canvas {
      max-width: 100%;
      margin-top: 1rem;
    }

    #goalStatus {
      margin-top: 0.8rem;
      font-weight: bold;
      font-size: 1rem;
    }

    @media (max-width: 400px) {
      .timer {
        font-size: 2rem;
      }

      button {
        font-size: 0.9rem;
        padding: 0.8rem;
      }
    }
  </style>
</head>
<body>

  <h1>ğŸ“š ÙˆÙ‚Øª Ø¯Ø±Ø§Ø³ØªÙŠ</h1>

  <div class="timer" id="timer">00:00:00</div>

  <div class="buttons">
    <button onclick="startTimer()">Ø§Ø¨Ø¯Ø£</button>
    <button onclick="pauseTimer()">Ø¥ÙŠÙ‚Ø§Ù</button>
    <button onclick="startBreak()">Ø§Ø³ØªØ±Ø§Ø­Ø©</button>
  </div>

  <div class="info">
    <p>ğŸ“† Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„ÙˆÙ‚Øª: <span id="totalTime">00:00:00</span></p>
    <p>ğŸ¯ Ø¹Ø¯Ø¯ Ø§Ù„Ø¬Ù„Ø³Ø§Øª: <span id="sessionCount">0</span></p>
  </div>

  <!-- Ø¥Ø¶Ø§ÙØ© Ù‚Ø³Ù… Ø§Ù„Ù‡Ø¯Ù -->
  <div class="section">
    <h2>ğŸ¯ Ù‡Ø¯Ù Ø§Ù„Ø¯Ø±Ø§Ø³Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠ (Ø³Ø§Ø¹Ø§Øª)</h2>
    <input type="number" id="goalInput" min="0" step="0.1" value="2" />
    <div id="goalStatus"></div>
    <button onclick="saveGoal()">Ø­ÙØ¸ Ø§Ù„Ù‡Ø¯Ù</button>
  </div>

  <div class="section">
    <h2>ğŸ’¡ ØªØ­ÙÙŠØ² Ø§Ù„ÙŠÙˆÙ…</h2>
    <p id="motivation"></p>
  </div>

  <div class="section">
    <h2>ğŸ•’ Ù…Ø¯Ø© Ø§Ù„Ø§Ø³ØªØ±Ø§Ø­Ø© (Ø¨Ø§Ù„Ø¯Ù‚Ø§Ø¦Ù‚)</h2>
    <input type="number" id="breakDuration" value="5" min="1" max="60" />
    <p id="breakTimer" style="margin-top: 0.5rem; font-size: 1.5rem; color: #e65100;"></p>
  </div>

  <div class="section">
    <h2>ğŸ“ˆ ØªÙ‚Ø¯Ù‘Ù… Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹</h2>
    <button onclick="saveTodayProgress()">ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªÙ‚Ø¯Ù… Ø§Ù„ÙŠÙˆÙ…ÙŠ</button>
    <canvas id="progressChart"></canvas>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
    // ---- IndexedDB setup ----
    const dbName = "StudyTrackerDB";
    const storeName = "studyData";
    const goalStoreName = "goalData";
    let db;

    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, 1);

        request.onupgradeneeded = (event) => {
          db = event.target.result;
          if (!db.objectStoreNames.contains(storeName)) {
            db.createObjectStore(storeName, { keyPath: "date" });
          }
          if (!db.objectStoreNames.contains(goalStoreName)) {
            db.createObjectStore(goalStoreName, { keyPath: "id" });
          }
        };

        request.onsuccess = (event) => {
          db = event.target.result;
          resolve(db);
        };

        request.onerror = () => reject("Ø®Ø·Ø£ Ø¨ÙØªØ­ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª");
      });
    }

    async function saveTodayData(dateStr, studySeconds, sessionsCount) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, "readwrite");
        const store = tx.objectStore(storeName);
        const data = { date: dateStr, studySeconds, sessionsCount };
        const request = store.put(data);

        request.onsuccess = () => resolve();
        request.onerror = () => reject("Ø®Ø·Ø£ Ø¨Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª");
      });
    }

    async function getDataByDate(dateStr) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, "readonly");
        const store = tx.objectStore(storeName);
        const request = store.get(dateStr);

        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject("Ø®Ø·Ø£ Ø¨ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª");
      });
    }

    // ---- ØªØ®Ø²ÙŠÙ† ÙˆÙ‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù‡Ø¯Ù ----
    async function saveGoalValue(goalHours) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(goalStoreName, "readwrite");
        const store = tx.objectStore(goalStoreName);
        const request = store.put({ id: 1, goalHours });

        request.onsuccess = () => resolve();
        request.onerror = () => reject("Ø®Ø·Ø£ Ø¨Ø­ÙØ¸ Ø§Ù„Ù‡Ø¯Ù");
      });
    }

    async function getGoalValue() {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(goalStoreName, "readonly");
        const store = tx.objectStore(goalStoreName);
        const request = store.get(1);

        request.onsuccess = () => resolve(request.result ? request.result.goalHours : null);
        request.onerror = () => reject("Ø®Ø·Ø£ Ø¨ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù‡Ø¯Ù");
      });
    }

    // Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ø±Ø§Ø³Ø©
    let startTime, timerInterval;
    let totalSeconds = 0;
    let isRunning = false;
    let breakInterval;

    const timerEl = document.getElementById("timer");
    const totalEl = document.getElementById("totalTime");
    const sessionEl = document.getElementById("sessionCount");
    const goalInput = document.getElementById("goalInput");
    const goalStatus = document.getElementById("goalStatus");

    // Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ø­Ø§Ù„ÙŠ
    function todayString() {
      return new Date().toDateString();
    }

    async function loadTodayProgress() {
      const today = todayString();
      const data = await getDataByDate(today);
      if (data) {
        totalSeconds = data.studySeconds || 0;
        sessionEl.textContent = data.sessionsCount || 0;
      } else {
        totalSeconds = 0;
        sessionEl.textContent = "0";
      }
      updateDisplay();
      updateGoalStatus();
    }

    async function loadGoal() {
      const goal = await getGoalValue();
      if (goal !== null) {
        goalInput.value = goal;
        updateGoalStatus();
      }
    }

    async function saveGoal() {
      let val = parseFloat(goalInput.value);
      if (isNaN(val) || val < 0) {
        alert("Ø±Ø¬Ø§Ø¡Ù‹ Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ù‡Ø¯Ù ØµØ­ÙŠØ­");
        return;
      }
      await saveGoalValue(val);
      updateGoalStatus();
      alert("âœ… ØªÙ… Ø­ÙØ¸ Ù‡Ø¯Ù Ø§Ù„Ø¯Ø±Ø§Ø³Ø©");
    }

    function updateGoalStatus() {
      let goalHours = parseFloat(goalInput.value);
      if (isNaN(goalHours) || goalHours <= 0) {
        goalStatus.textContent = "";
        return;
      }
      let studiedHours = totalSeconds / 3600;
      if (studiedHours >= goalHours) {
        goalStatus.textContent = "ğŸ‰ Ù…Ø¨Ø±ÙˆÙƒ! ÙˆØµÙ„Øª Ù„Ù‡Ø¯ÙÙƒ Ø§Ù„ÙŠÙˆÙ… âœ…";
        goalStatus.style.color = "green";
      } else {
        let remaining = (goalHours - studiedHours).toFixed(2);
        goalStatus.textContent = `ğŸ“Œ ØªØ¨Ù‚Ù‰ ${remaining} Ø³Ø§Ø¹Ø§Øª Ù„ØªØ­Ù‚ÙŠÙ‚ Ø§Ù„Ù‡Ø¯Ù`;
        goalStatus.style.color = "orange";
      }
    }

    window.onload = async function () {
      await loadTodayProgress();
      await loadGoal();
      showMotivation();
      updateChart();
    };

    function startTimer() {
      if (isRunning) return;
      isRunning = true;
      startTime = Date.now();
      timerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        timerEl.textContent = formatTime(elapsed);
      }, 1000);
    }

    async function pauseTimer() {
      if (!isRunning) return;
      isRunning = false;
      clearInterval(timerInterval);
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      totalSeconds += elapsed;
      timerEl.textContent = "00:00:00";
      updateDisplay();
      let count = parseInt(sessionEl.textContent) || 0;
      count++;
      sessionEl.textContent = count;
      await saveTodayData(todayString(), totalSeconds, count);
      updateGoalStatus();
    }

    function updateDisplay() {
      totalEl.textContent = formatTime(totalSeconds);
    }

    function formatTime(seconds) {
      const h = String(Math.floor(seconds / 3600)).padStart(2, "0");
      const m = String(Math.floor((seconds % 3600) / 60)).padStart(2, "0");
      const s = String(seconds % 60).padStart(2, "0");
      return `${h}:${m}:${s}`;
    }

    function startBreak() {
      const minutes = parseInt(document.getElementById("breakDuration").value) || 5;
      let breakSeconds = minutes * 60;
      const breakTimer = document.getElementById("breakTimer");
      breakTimer.textContent = formatTime(breakSeconds);

      if (breakInterval) clearInterval(breakInterval);

      breakInterval = setInterval(() => {
        breakSeconds--;
        breakTimer.textContent = formatTime(breakSeconds);
        if (breakSeconds <= 0) {
          clearInterval(breakInterval);
          breakTimer.textContent = "";

          const msg = document.createElement("div");
          msg.textContent = "âœ… Ø§Ù†ØªÙ‡Ù‰ ÙˆÙ‚Øª Ø§Ù„Ø±Ø§Ø­Ø©! Ø´Ø¯ Ø§Ù„Ù‡Ù…Ø© âœ¨";
          msg.style.padding = "1rem";
          msg.style.background = "#d4edda";
          msg.style.color = "#155724";
          msg.style.border = "1px solid #c3e6cb";
          msg.style.borderRadius = "10px";
          msg.style.margin = "1rem auto";
          msg.style.textAlign = "center";
          msg.style.fontWeight = "bold";

          const container = breakTimer.parentElement;
          const oldMsg = container.querySelector(".break-message");
          if (oldMsg) oldMsg.remove();

          msg.classList.add("break-message");
          container.appendChild(msg);

          if (navigator.vibrate) {
            navigator.vibrate([200, 100, 200]);
          }
        }
      }, 1000);
    }

    function showMotivation() {
      const messages = [
        "Ø§Ù„ÙŠÙˆÙ… Ø£ÙØ¶Ù„ ÙˆÙ‚Øª Ù„Ù„Ø¨Ø¯Ø¡! ğŸš€",
        "Ø£Ù†Øª ØªÙ‚ØªØ±Ø¨ Ù…Ù† Ù‡Ø¯ÙÙƒ ÙƒÙ„ Ø¯Ù‚ÙŠÙ‚Ø©. ğŸ’ª",
        "Ù„Ø§ ØªØ¶ØºØ· Ø¹Ù„Ù‰ Ù†ÙØ³Ùƒ... Ø®Ø·ÙˆØ© ÙƒÙ„ ÙŠÙˆÙ… ØªÙƒÙÙŠ. ğŸŒ±",
        "ÙƒÙ„ ØªØ¹Ø¨Ùƒ Ø§Ù„ÙŠÙˆÙ… Ø±Ø­ ØªÙØ±Ø­ ÙÙŠÙ‡ Ø¨ÙƒØ±Ø§. ğŸ†",
        "Ø§Ø³ØªÙ…Ø±! Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ ÙŠØ¨ØªØ³Ù… Ù„Ùƒ. âœ¨"
      ];
      const index = new Date().getDay() % messages.length;
      document.getElementById("motivation").textContent = messages[index];
    }

    // Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠ
    const chartDays = ["Ø§Ù„Ø£Ø­Ø¯", "Ø§Ù„Ø§Ø«Ù†ÙŠÙ†", "Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡", "Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡", "Ø§Ù„Ø®Ù…ÙŠØ³", "Ø§Ù„Ø¬Ù…Ø¹Ø©", "Ø§Ù„Ø³Ø¨Øª"];
    let weeklyData = [];

    async function loadWeeklyProgress() {
      weeklyData = [];
      for (let i = 0; i < 7; i++) {
        const dayDate = new Date();
        dayDate.setDate(dayDate.getDate() - ((dayDate.getDay() + 7 - i) % 7));
        const dayStr = dayDate.toDateString();
        const data = await getDataByDate(dayStr);
        weeklyData[i] = data ? +(data.studySeconds / 3600).toFixed(2) : 0;
      }
    }

    async function saveTodayProgress() {
      await saveTodayData(todayString(), totalSeconds, parseInt(sessionEl.textContent) || 0);
      alert("âœ… ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªÙ‚Ø¯Ù… Ù„Ù„ÙŠÙˆÙ…!");
      await loadWeeklyProgress();
      updateChart();
    }

    let chart;
    async function updateChart() {
      await loadWeeklyProgress();
      const ctx = document.getElementById('progressChart').getContext('2d');
      if (chart) chart.destroy();
      chart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: chartDays,
          datasets: [{
            label: 'Ø¹Ø¯Ø¯ Ø³Ø§Ø¹Ø§Øª Ø§Ù„Ø¯Ø±Ø§Ø³Ø©',
            data: weeklyData,
            backgroundColor: '#4CAF50'
          }]
        },
        options: {
          scales: {
            y: {
              beginAtZero: true,
              ticks: { stepSize: 1 }
            }
          }
        }
      });
    }

    // Service Worker ØªØ³Ø¬ÙŠÙ„
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js')
      .then(() => console.log('ØªÙ… ØªØ³Ø¬ÙŠÙ„ Service Worker Ø¨Ù†Ø¬Ø§Ø­'))
      .catch(err => console.error('ÙØ´Ù„ ØªØ³Ø¬ÙŠÙ„ Service Worker:', err));
    }

  </script>

</body>
</html>
